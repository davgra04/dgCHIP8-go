package chip8

import (
	"fmt"
	"strings"
	"testing"
)

var chipCfg *Config
var chip *CHIP8
var done chan<- bool

////////////////////////////////////////////////////////////////////////////////
// debug functions
////////////////////////////////////////////////////////////////////////////////

func sprintDisplay(chip *CHIP8) string {

	var b strings.Builder

	for i := range chip.Display {
		if (i*8)%chip.Cfg.ResolutionX == 0 {
			fmt.Fprintf(&b, "\n")
		}
		fmt.Fprintf(&b, "%08b ", chip.Display[i])
	}
	fmt.Fprintf(&b, "\n")

	return b.String()
}

func sprintExpectedDisplay(expected [32]uint64) string {
	var b strings.Builder

	fmt.Fprintf(&b, "\n")

	for _, row := range expected {
		for i := 0; i < 8; i++ {
			shiftAmt := (7 - i) * 8
			byteToDraw := uint8(row >> shiftAmt)
			fmt.Fprintf(&b, "%08b ", byteToDraw)
		}
		fmt.Fprintf(&b, "\n")
	}

	return b.String()
}

func compareDisplay(t *testing.T, chip *CHIP8, expected [32]uint64) {

	for rowIdx, row := range expected {

		for i := 7; i >= 0; i-- {
			displayIdx := rowIdx*8 + i
			actualByte := chip.Display[displayIdx]
			shiftAmt := (7 - i) * 8
			expectedByte := uint8(row >> shiftAmt)

			if actualByte != expectedByte {
				t.Errorf("chip.Display does not match expection; got:%v\nwant:%v\n", sprintDisplay(chip), sprintExpectedDisplay(expected))
				return
			}
		}

	}
}

////////////////////////////////////////////////////////////////////////////////
// tests
////////////////////////////////////////////////////////////////////////////////

// 00E0 - CLS
// Clear the display.
func TestInstructionClearScreen(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	for i := range chip.Display {
		chip.Display[i] = 0xba
	}

	chip.WriteShort(0x200, 0x00e0)

	chip.StepEmulation()

	for i := range chip.Display {
		if chip.Display[i] != 0 {
			t.Errorf("chip.Display[0x%x] = 0x%x; want 0", i, chip.Display[i])
		}
	}
}

// 2nnn - CALL addr
// Call subroutine at nnn.

// 00EE - RET
// Return from a subroutine.
func TestInstructionCallReturnSubroutine(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.WriteShort(0x200, 0x2abc)
	chip.WriteShort(0x202, 0x2abc)
	chip.WriteShort(0xabc, 0x00ee)

	var tests = []struct {
		StackPtr    uint8
		StackValue0 uint16
		PC          uint16
	}{
		{0x1, 0x202, 0xabc},
		{0x0, 0x202, 0x202},
		{0x1, 0x204, 0xabc},
		{0x0, 0x204, 0x204},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.StackPtr != want.StackPtr {
			t.Errorf("test %d: chip.StackPtr = 0x%x; want 0x%x", i, chip.StackPtr, want.StackPtr)
		}

		if chip.Stack[0] != want.StackValue0 {
			t.Errorf("test %d: chip.Stack[0] = 0x%x; want 0x%x", i, chip.Stack[0], want.StackValue0)
		}

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// 1nnn - JP addr
// Jump to location nnn.
func TestInstructionJump(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.WriteShort(0x200, 0x1abc)
	chip.WriteShort(0xabc, 0x1def)

	var tests = []struct {
		PC uint16
	}{
		{0xabc},
		{0xdef},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// 3xkk - SE Vx, byte
// Skip next instruction if Vx = kk.
func TestInstructionSkipEqualByte(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba
	chip.Reg[0xa] = 0xdc

	chip.WriteShort(0x200, 0x31ba) // SE V1, 0xba	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0x3add) // SE Va, 0xdd	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// 4xkk - SNE Vx, byte
// Skip next instruction if Vx != kk.
func TestInstructionSkipNotEqualByte(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba
	chip.Reg[0xa] = 0xdc

	chip.WriteShort(0x200, 0x41bb) // SNE V1, 0xbb	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0x4adc) // SNE Va, 0xdc	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// 5xy0 - SE Vx, Vy
// Skip next instruction if Vx = Vy.
func TestInstructionSkipEqualReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba
	chip.Reg[0xa] = 0xdc
	chip.Reg[0xc] = 0xdc

	chip.WriteShort(0x200, 0x5ac0) // SE Va, Vc	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0x51a0) // SE V1, Va	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// 6xkk - LD Vx, byte
// Set Vx = kk.
func TestInstructionLoadByte(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.WriteShort(0x200, 0x6a44)

	chip.StepEmulation()

	if chip.Reg[0xa] != 0x44 {
		t.Errorf("chip.Reg[0xa] = 0x%x; want 0x44", chip.Reg[0xa])
	}
}

// 7xkk - ADD Vx, byte
// Set Vx = Vx + kk.
func TestInstructionAddByte(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0x10
	chip.Reg[0x1] = 0xff

	chip.WriteShort(0x200, 0x7001)
	chip.WriteShort(0x202, 0x7101)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
	}{
		{0x202, 0x0, 0x11},
		{0x204, 0x1, 0x00},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}
	}
}

// 8xy0 - LD Vx, Vy
// Set Vx = Vy.
func TestInstructionLoadReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xff

	chip.WriteShort(0x200, 0x8210)

	chip.StepEmulation()

	if chip.Reg[0x2] != chip.Reg[0x1] {
		t.Errorf("chip.Reg[0x2] = 0x%x; want 0x%x", chip.Reg[0x2], chip.Reg[0x1])
	}
}

// 8xy1 - OR Vx, Vy
// Set Vx = Vx OR Vy.
func TestInstructionOr(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xaa
	chip.Reg[0x1] = 0x55

	chip.WriteShort(0x200, 0x8011)
	chip.WriteShort(0x202, 0x8231)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
	}{
		{0x202, 0x0, 0xff},
		{0x204, 0x2, 0x00},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}
	}
}

// 8xy2 - AND Vx, Vy
// Set Vx = Vx AND Vy.
func TestInstructionAnd(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xaa
	chip.Reg[0x1] = 0x55
	chip.Reg[0x2] = 0xff
	chip.Reg[0x3] = 0xaa

	chip.WriteShort(0x200, 0x8012)
	chip.WriteShort(0x202, 0x8232)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
	}{
		{0x202, 0x0, 0x00},
		{0x204, 0x2, 0xaa},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}
	}
}

// 8xy3 - XOR Vx, Vy
// Set Vx = Vx XOR Vy.
func TestInstructionXor(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0x3c // 0011 1100
	chip.Reg[0x1] = 0x0f // 0000 1111

	chip.WriteShort(0x200, 0x8013)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
	}{
		{0x202, 0x0, 0x33},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}
	}
}

// 8xy4 - ADD Vx, Vy
// Set Vx = Vx + Vy, set VF = carry.
func TestInstructionAddReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0x00
	chip.Reg[0x1] = 0x01
	chip.Reg[0x2] = 0xff
	chip.Reg[0x3] = 0x04

	chip.WriteShort(0x200, 0x8014)
	chip.WriteShort(0x202, 0x8234)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
		carry  uint8
	}{
		{0x202, 0x0, 0x01, 0x0},
		{0x204, 0x2, 0x03, 0x1},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}

		if chip.Reg[0xf] != want.carry {
			t.Errorf("test %d: chip.Reg[0xf] = 0x%x; want 0x%x", i, chip.Reg[0xf], want.carry)
		}
	}
}

// 8xy5 - SUB Vx, Vy
// Set Vx = Vx - Vy, set VF = NOT borrow.
func TestInstructionSubReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xff
	chip.Reg[0x1] = 0x0f
	chip.Reg[0x2] = 0x02
	chip.Reg[0x3] = 0x04

	chip.WriteShort(0x200, 0x8015)
	chip.WriteShort(0x202, 0x8235)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
		carry  uint8
	}{
		{0x202, 0x0, 0xf0, 0x1},
		{0x204, 0x2, 0xfe, 0x0},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}

		if chip.Reg[0xf] != want.carry {
			t.Errorf("test %d: chip.Reg[0xf] = 0x%x; want 0x%x", i, chip.Reg[0xf], want.carry)
		}
	}
}

// 8xy6 - SHR Vx
// Set Vx = Vx SHR 1.
func TestInstructionShiftRight(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xf0
	chip.Reg[0x1] = 0x0f

	chip.WriteShort(0x200, 0x8006)
	chip.WriteShort(0x202, 0x8106)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
		carry  uint8
	}{
		{0x202, 0x0, 0x78, 0x0},
		{0x204, 0x1, 0x07, 0x1},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}

		if chip.Reg[0xf] != want.carry {
			t.Errorf("test %d: chip.Reg[0xf] = 0x%x; want 0x%x", i, chip.Reg[0xf], want.carry)
		}
	}
}

// 8xy7 - SUBN Vx, Vy
// Set Vx = Vy - Vx, set VF = NOT borrow.
func TestInstructionSubNReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0x0f
	chip.Reg[0x1] = 0xff
	chip.Reg[0x2] = 0x04
	chip.Reg[0x3] = 0x02

	chip.WriteShort(0x200, 0x8017)
	chip.WriteShort(0x202, 0x8237)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
		carry  uint8
	}{
		{0x202, 0x0, 0xf0, 0x1},
		{0x204, 0x2, 0xfe, 0x0},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}

		if chip.Reg[0xf] != want.carry {
			t.Errorf("test %d: chip.Reg[0xf] = 0x%x; want 0x%x", i, chip.Reg[0xf], want.carry)
		}
	}
}

// 8xyE - SHL Vx {, Vy}
// Set Vx = Vx SHL 1.
func TestInstructionShiftLeft(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xf0
	chip.Reg[0x1] = 0x0f

	chip.WriteShort(0x200, 0x800e)
	chip.WriteShort(0x202, 0x810e)

	var tests = []struct {
		PC     uint16
		regIdx uint8
		regVal uint8
		carry  uint8
	}{
		{0x202, 0x0, 0xe0, 0x1},
		{0x204, 0x1, 0x1e, 0x0},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[want.regIdx] != want.regVal {
			t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, want.regIdx, chip.Reg[want.regIdx], want.regVal)
		}

		if chip.Reg[0xf] != want.carry {
			t.Errorf("test %d: chip.Reg[0xf] = 0x%x; want 0x%x", i, chip.Reg[0xf], want.carry)
		}
	}
}

// 9xy0 - SNE Vx, Vy
// Skip next instruction if Vx != Vy.
func TestInstructionSkipNotEqualReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba
	chip.Reg[0x2] = 0xdc
	chip.Reg[0x3] = 0xdc

	chip.WriteShort(0x200, 0x9120) // SNE V1, V2	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0x9ad0) // SNE V2, V3	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// Annn - LD I, addr
// Set I = nnn.
func TestInstructionLoadRegI(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.WriteShort(0x200, 0xabcd)

	chip.StepEmulation()

	if chip.RegI != 0xbcd {
		t.Errorf("chip.RegI = 0x%x; want 0xbcd", chip.Reg[0xa])
	}
}

// Bnnn - JP V0, addr
// Jump to location nnn + V0.
func TestInstructionJumpReg(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0xff

	chip.WriteShort(0x200, 0xb400)

	chip.StepEmulation()

	if chip.PC != 0x4ff {
		t.Errorf("chip.PC = 0x%x; want 0x4ff", chip.PC)
	}
}

// Cxkk - RND Vx, byte
// Set Vx = random byte AND kk.

//     skipping for now, not sure how to check if a random byte was written
//     maybe set the seed for RNG and validate the bitwise AND with kk

// Dxyn - DRW Vx, Vy, nibble
// Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
func TestInstructionDrawSpriteNoWrap(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Cfg.DrawWrap = false // disable wrapping

	// sprite data
	chip.WriteByte(0x400, 0b11110000)
	chip.WriteByte(0x401, 0b11110000)
	chip.RegI = 0x400

	// test normal drawing
	////////////////////////////////////////

	chip.Reg[0x0] = 0
	chip.Reg[0x1] = 1
	chip.Reg[0x2] = 60
	chip.Reg[0x3] = 31
	chip.Reg[0x4] = 66
	chip.Reg[0x5] = 34

	chip.WriteShort(0x200, 0xd002)
	chip.WriteShort(0x202, 0xd112)

	// draw this first:
	//     11110000
	//     11110000
	//     00000000

	chip.StepEmulation()

	expected := [32]uint64{
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// then draw this
	//     00000000
	//     01111000
	//     01111000

	// which should result in this
	//     11110000
	//     10001000
	//     01111000

	chip.StepEmulation()

	expected = [32]uint64{
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b1000100000000000000000000000000000000000000000000000000000000000,
		0b0111100000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test non-wrapped drawing at bottom edge
	////////////////////////////////////////
	chip.WriteByte(0x400, 0b11111111)
	chip.WriteByte(0x401, 0b11111111)

	chip.clearDisplay()
	chip.WriteShort(0x204, 0xd132) // draw 2 bytes at 1, 31
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0111111110000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test non-wrapped drawing at right edge
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x206, 0xd212) // draw 2 bytes at 60, 1
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000001111,
		0b0000000000000000000000000000000000000000000000000000000000001111,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test non-wrapped drawing at bottom right corner
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x208, 0xd232)
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000001111,
	}

	compareDisplay(t, chip, expected)

	// test non-wrapped drawing offscreen
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x20a, 0xd452)
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)
}

func TestInstructionDrawSpriteWrap(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Cfg.DrawWrap = true // enable wrapping

	// sprite data
	chip.WriteByte(0x400, 0b11110000)
	chip.WriteByte(0x401, 0b11110000)
	chip.RegI = 0x400

	// test normal drawing
	////////////////////////////////////////

	chip.Reg[0x0] = 0
	chip.Reg[0x1] = 1
	chip.Reg[0x2] = 60
	chip.Reg[0x3] = 31
	chip.Reg[0x4] = 66
	chip.Reg[0x5] = 34

	chip.WriteShort(0x200, 0xd002)
	chip.WriteShort(0x202, 0xd112)

	// draw this first:
	//     11110000
	//     11110000
	//     00000000

	chip.StepEmulation()

	expected := [32]uint64{
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// then draw this
	//     00000000
	//     01111000
	//     01111000

	// which should result in this
	//     11110000
	//     10001000
	//     01111000

	chip.StepEmulation()

	expected = [32]uint64{
		0b1111000000000000000000000000000000000000000000000000000000000000,
		0b1000100000000000000000000000000000000000000000000000000000000000,
		0b0111100000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test wrapped drawing at bottom edge
	////////////////////////////////////////
	chip.WriteByte(0x400, 0b11111111)
	chip.WriteByte(0x401, 0b11111111)

	chip.clearDisplay()
	chip.WriteShort(0x204, 0xd132) // draw 2 bytes at 1, 31
	chip.StepEmulation()

	expected = [32]uint64{
		0b0111111110000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0111111110000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test wrapped drawing at right edge
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x206, 0xd212) // draw 2 bytes at 60, 1
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b1111000000000000000000000000000000000000000000000000000000001111,
		0b1111000000000000000000000000000000000000000000000000000000001111,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

	// test wrapped drawing at bottom right corner
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x208, 0xd232)
	chip.StepEmulation()

	expected = [32]uint64{
		0b1111000000000000000000000000000000000000000000000000000000001111,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b1111000000000000000000000000000000000000000000000000000000001111,
	}

	compareDisplay(t, chip, expected)

	// test wrapped drawing offscreen
	////////////////////////////////////////
	chip.clearDisplay()
	chip.WriteShort(0x20a, 0xd452)
	chip.StepEmulation()

	expected = [32]uint64{
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0011111111000000000000000000000000000000000000000000000000000000,
		0b0011111111000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
		0b0000000000000000000000000000000000000000000000000000000000000000,
	}

	compareDisplay(t, chip, expected)

}

// Ex9E - SKP Vx
// Skip next instruction if key with the value of Vx is pressed.
func TestInstructionSkipKey(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xa
	chip.Reg[0x2] = 0xb

	chip.Keys[0xb] = true // b key is pressed

	chip.WriteShort(0x200, 0xe29e) // SKP V2	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0xe19e) // SKP V1	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// ExA1 - SKNP Vx
// Skip next instruction if key with the value of Vx is not pressed.
func TestInstructionSkipNotKey(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xa
	chip.Reg[0x2] = 0xb

	chip.Keys[0xb] = true // b key is pressed

	chip.WriteShort(0x200, 0xe1a1) // SKNP V1	(should skip)
	chip.WriteShort(0x202, 0x1aaa) // jump away
	chip.WriteShort(0x204, 0xe2a1) // SKNP V2	(should not skip)

	var tests = []struct {
		PC uint16
	}{
		{0x204},
		{0x206},
	}

	for i, want := range tests {
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}
	}
}

// Fx07 - LD Vx, DT
// Set Vx = delay timer value.
func TestInstructionReadDelayTimer(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.RegDelay = 0xba
	chip.WriteShort(0x200, 0xf107)

	chip.StepEmulation()

	if chip.Reg[0x1] != 0xb9 {
		t.Errorf("chip.Reg[0x1] = 0x%x; want 0xb9", chip.Reg[0x1])
	}
}

// Fx0A - LD Vx, K
// Wait for a key press, store the value of the key in Vx.
func TestInstructionWaitForKey(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Keys[0xb] = true // b key is pressed before WaitForKey instruction is executed

	chip.WriteShort(0x200, 0xfa0a)

	var tests = []struct {
		PC           uint16
		KeyToPress   int
		KeyToRelease int
		RegAValue    uint8
	}{
		{0x200, -1, -1, 0x0},
		{0x200, -1, -1, 0x0},
		{0x200, -1, -1, 0x0},
		{0x200, -1, 0xb, 0x0},
		{0x200, -1, -1, 0x0},
		{0x200, -1, -1, 0x0},
		{0x200, 0xc, -1, 0x0},
		{0x202, -1, -1, 0xc},
	}

	for i, want := range tests {
		chip.StepEmulation()

		// fmt.Printf("i: %v\n", i)
		// fmt.Printf("    chip.Keys:     %v\n", chip.Keys)
		// fmt.Printf("    chip.KeysPrev: %v\n", chip.KeysPrev)

		// adjust keys
		if want.KeyToPress != -1 {
			chip.SetKeyState(uint8(want.KeyToPress), true)
		}

		if want.KeyToRelease != -1 {
			chip.SetKeyState(uint8(want.KeyToRelease), false)
		}

		// check state

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Reg[0xa] != want.RegAValue {
			t.Errorf("test %d: chip.Reg[0xa] = 0x%x; want 0x%x", i, chip.Reg[0xa], want.RegAValue)
		}
	}
}

// Fx15 - LD DT, Vx
// Set delay timer = Vx.
func TestInstructionSetDelayTimer(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba

	chip.WriteShort(0x200, 0xf115)

	chip.StepEmulation()

	if chip.RegDelay != 0xba {
		t.Errorf("chip.RegDelay = 0x%x; want 0xba", chip.RegDelay)
	}
}

// Fx18 - LD ST, Vx
// Set sound timer = Vx.
func TestInstructionSetSoundTimer(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0xba

	chip.WriteShort(0x200, 0xf118)

	chip.StepEmulation()

	if chip.RegSound != 0xba {
		t.Errorf("chip.RegSound = 0x%x; want 0xba", chip.RegSound)
	}
}

// Fx1E - ADD I, Vx
// Set I = I + Vx.
func TestInstructionAddRegI(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x1] = 0x11
	chip.RegI = 0x2222

	chip.WriteShort(0x200, 0xf11e)

	chip.StepEmulation()

	if chip.RegI != 0x2233 {
		t.Errorf("chip.RegI = 0x%x; want 0x2233", chip.RegI)
	}
}

// Fx29 - LD F, Vx
// Set I = location of sprite for digit Vx.
func TestInstructionLoadSprite(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.WriteShort(0x200, 0xfa29)
	chip.WriteShort(0x202, 0xfa29)
	chip.WriteShort(0x204, 0xfa29)
	chip.WriteShort(0x206, 0xfa29)
	chip.WriteShort(0x208, 0xfa29)
	chip.WriteShort(0x20a, 0xfa29)
	chip.WriteShort(0x20c, 0xfa29)
	chip.WriteShort(0x20e, 0xfa29)
	chip.WriteShort(0x210, 0xfa29)
	chip.WriteShort(0x212, 0xfa29)
	chip.WriteShort(0x214, 0xfa29)
	chip.WriteShort(0x216, 0xfa29)
	chip.WriteShort(0x218, 0xfa29)
	chip.WriteShort(0x21a, 0xfa29)
	chip.WriteShort(0x21c, 0xfa29)
	chip.WriteShort(0x21e, 0xfa29)

	var tests = []struct {
		PC        uint16
		RegAValue uint8
		RegIValue uint16
	}{
		{0x202, 0x0, 0x0},
		{0x204, 0x1, 0x5},
		{0x206, 0x2, 0xa},
		{0x208, 0x3, 0xf},
		{0x20a, 0x4, 0x14},
		{0x20c, 0x5, 0x19},
		{0x20e, 0x6, 0x1e},
		{0x210, 0x7, 0x23},
		{0x212, 0x8, 0x28},
		{0x214, 0x9, 0x2d},
		{0x216, 0xa, 0x32},
		{0x218, 0xb, 0x37},
		{0x21a, 0xc, 0x3c},
		{0x21c, 0xd, 0x41},
		{0x21e, 0xe, 0x46},
		{0x220, 0xf, 0x4b},
		{0x222, 0x10, 0x4b},
	}

	for i, want := range tests {
		// set RegA value
		chip.Reg[0xa] = want.RegAValue

		// step and check state
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.RegI != want.RegIValue {
			t.Errorf("test %d: chip.RegI = 0x%x; want 0x%x", i, chip.RegI, want.RegIValue)
		}
	}
}

// Fx33 - LD B, Vx
// Store BCD representation of Vx in memory locations I, I+1, and I+2.
func TestInstructionLoadBCD(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	chip.Reg[0x0] = 0
	chip.Reg[0x1] = 4
	chip.Reg[0x2] = 34
	chip.Reg[0x3] = 234

	chip.WriteShort(0x200, 0xf033)
	chip.WriteShort(0x202, 0xf133)
	chip.WriteShort(0x204, 0xf233)
	chip.WriteShort(0x206, 0xf333)

	var tests = []struct {
		PC         uint16
		TargetAddr uint16
		IVal       uint8
		IValPlus1  uint8
		IValPlus2  uint8
	}{
		{0x202, 0x600, 0, 0, 0},
		{0x204, 0x700, 0, 0, 4},
		{0x206, 0x800, 0, 3, 4},
		{0x208, 0x900, 2, 3, 4},
	}

	for i, want := range tests {
		// set RegI value
		chip.RegI = want.TargetAddr

		// step and check state
		chip.StepEmulation()

		// fmt.Printf("----------------------------------------\n")
		// fmt.Printf("I    0x%x\n", chip.RegI)
		// fmt.Printf("Reg%d %d\n", i, chip.Reg[i])
		// fmt.Printf("Mem[0x%x] %d\n", chip.RegI, chip.Memory[chip.RegI])
		// fmt.Printf("Mem[0x%x] %d\n", chip.RegI+1, chip.Memory[chip.RegI+1])
		// fmt.Printf("Mem[0x%x] %d\n", chip.RegI+2, chip.Memory[chip.RegI+2])

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		if chip.Memory[chip.RegI] != want.IVal {
			t.Errorf("test %d: chip.Memory[chip.RegI] = 0x%x; want 0x%x", i, chip.Memory[chip.RegI], want.IVal)
		}

		if chip.Memory[chip.RegI+1] != want.IValPlus1 {
			t.Errorf("test %d: chip.Memory[chip.RegI+1] = 0x%x; want 0x%x", i, chip.Memory[chip.RegI+1], want.IValPlus1)
		}

		if chip.Memory[chip.RegI+2] != want.IValPlus2 {
			t.Errorf("test %d: chip.Memory[chip.RegI+2] = 0x%x; want 0x%x", i, chip.Memory[chip.RegI+2], want.IValPlus2)
		}
	}
}

// Fx55 - LD [I], Vx
// Store registers V0 through Vx in memory starting at location I.
func TestInstructionLoadMulti(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	// initialize registers to 0xf0 - 0xff
	for i := 0; i < 16; i++ {
		chip.Reg[i] = 0xf0 + uint8(i)
	}

	chip.WriteShort(0x200, 0xf555)
	chip.WriteShort(0x202, 0xff55)

	var tests = []struct {
		PC         uint16
		TargetAddr uint16
		Values     []uint8
	}{
		{0x202, 0x300, []uint8{
			0xf0,
			0xf1,
			0xf2,
			0xf3,
			0xf4,
			0xf5,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
		}},
		{0x204, 0x400, []uint8{
			0xf0,
			0xf1,
			0xf2,
			0xf3,
			0xf4,
			0xf5,
			0xf6,
			0xf7,
			0xf8,
			0xf9,
			0xfa,
			0xfb,
			0xfc,
			0xfd,
			0xfe,
			0xff,
		}},
	}

	for i, want := range tests {
		// set RegI value
		chip.RegI = want.TargetAddr

		// step and check state
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		for j := range want.Values {
			if chip.Memory[chip.RegI+uint16(j)] != want.Values[j] {
				t.Errorf("test %d: chip.Memory[0x%x + 0x%x] = 0x%x; want 0x%x", i, chip.RegI, j, chip.Memory[chip.RegI+uint16(j)], want.Values[j])
			}
		}
	}
}

// Fx65 - LD Vx, [I]
// Read registers V0 through Vx from memory starting at location I.
func TestInstructionReadMulti(t *testing.T) {
	chipCfg := GetDefaultConfig()
	chip, _ := NewCHIP8(chipCfg)

	// initialize memory block to 0xf0 - 0xff and registers to 0xba
	for i := 0; i < 16; i++ {
		chip.Memory[0x600+i] = 0xf0 + uint8(i)
		chip.Reg[i] = 0xbb
	}
	chip.RegI = 0x600

	chip.WriteShort(0x200, 0xf565)
	chip.WriteShort(0x202, 0xff65)

	var tests = []struct {
		PC     uint16
		Values []uint8
	}{
		{0x202, []uint8{
			0xf0,
			0xf1,
			0xf2,
			0xf3,
			0xf4,
			0xf5,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
			0xbb,
		}},
		{0x204, []uint8{
			0xf0,
			0xf1,
			0xf2,
			0xf3,
			0xf4,
			0xf5,
			0xf6,
			0xf7,
			0xf8,
			0xf9,
			0xfa,
			0xfb,
			0xfc,
			0xfd,
			0xfe,
			0xff,
		}},
	}

	for i, want := range tests {
		// step and check state
		chip.StepEmulation()

		if chip.PC != want.PC {
			t.Errorf("test %d: chip.PC = 0x%x; want 0x%x", i, chip.PC, want.PC)
		}

		for j := range want.Values {
			if chip.Reg[j] != want.Values[j] {
				t.Errorf("test %d: chip.Reg[0x%x] = 0x%x; want 0x%x", i, j, chip.Reg[j], want.Values[j])
			}
		}
	}
}
